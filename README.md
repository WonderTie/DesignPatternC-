# DesignPatternC++
基于C++实现的常用的九大设计模式（创建型模式、结构型模式、行为型模式各三类）

## 设计模式

设计模式是在软件工程中，为解决特定问题而经过反复验证、具有一定普遍性的经验总结。设计模式可以提高软件的可重用性、灵活性和可维护性，并且可以使代码更易懂、更易修改和更易测试。

在设计模式中按照不同的处理⽅式共包含三⼤类：

1. 创建型模式：创建型模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象。可以使程序在判断针对某个给定实例需要创建哪些对象时更加灵活。
2. 结构型模式：结构型模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。
3. 行为型模式：行为模式特别关注对象之间的通信。

### 创建型模式

#### 工厂方法模式（Factory Method Pattern）

将对象的创建延迟到子类中实现，也就是定义一个工厂接口和多个工厂实现类，每个工厂实现类都负责创建一种具体的产品对象。适用于需要创建一组相关的产品对象。

**优点：** 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。

**缺点：**每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

**使用场景：** 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。

**示例**：

创建一个 *Shape* 接口和实现 *Shape* 接口的实体类。下一步是定义工厂类 *ShapeFactory*。*FactoryPatternDemo* 类使用 *ShapeFactory* 来获取 *Shape* 对象。它将向 *ShapeFactory* 传递信息（*CIRCLE / RECTANGLE / SQUARE*），以便获取它所需对象的类型。![工厂模式的 UML 图](assets/设计模式/AB6B814A-0B09-4863-93D6-1E22D6B07FF8.jpg)

#### 单例模式（Singleton Pattern）

确保类只有一个实例，并提供全局访问点。适用于需要全局共享一个对象的情况。

**优点：**

- 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。
- 2、避免对资源的多重占用（比如写文件操作）。

**缺点：**没有接口，不能继承，与单一职责原则冲突.

**使用场景：**

- 1、要求生产唯一序列号。
- 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。
- 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。

**两种实现方式**：

- 饿汉式：是指在程序启动时就创建实例对象，即“饿”着。在多线程环境下，由于对象已经被创建，所以不需要加锁，因此饿汉式天生就是线程安全的。饿汉式的缺点是，在整个程序的运行期间，实例对象始终存在，如果实例对象比较大，会占用一定的内存空间。
- 懒汉式：是指在需要使用实例对象时才进行创建，即“懒”着。在单线程环境下，懒汉式是比较简单的，只需要在第一次使用时进行实例对象的创建即可。但在多线程环境下，需要考虑线程安全问题。常见的解决方式是使用双重检查锁定（Double-Checked Locking）来保证线程安全。

**示例**：创建一个 *SingleObject* 类。*SingleObject* 类有它的私有构造函数和本身的一个静态实例。*SingleObject* 类提供了一个静态方法，供外界获取它的静态实例。*SingletonPatternDemo* 类使用 *SingleObject* 类来获取 *SingleObject* 对象。![单例模式的 UML 图](assets/设计模式/62576915-36E0-4B67-B078-704699CA980A.jpg)

#### 建造者模式（Builder Pattern）

将一个复杂对象的构建过程分解为多个简单对象的构建过程，并通过一个指挥者来协调这些对象的构建过程，最终构建出一个完整的复杂对象。适用于需要创建复杂对象的情况。

**优点：** 1、建造者独立，易扩展。 2、便于控制细节风险。

**缺点：** 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。

**使用场景：** 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。

**示例**：假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。我们将创建一个表示食物条目（比如汉堡和冷饮）的 *Item* 接口和实现 *Item* 接口的实体类，以及一个表示食物包装的 *Packing* 接口和实现 *Packing* 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。然后我们创建一个 *Meal* 类，带有 *Item* 的 *ArrayList* 和一个通过结合 *Item* 来创建不同类型的 *Meal* 对象的 *MealBuilder*。*BuilderPatternDemo* 类使用 *MealBuilder* 来创建一个 *Meal*。![建造者模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20210315-builder-pattern.svg)

### 结构型模式

#### 适配器模式(Adapter Pattern)

适配器模式旨在将现有类的接口转换为另一个接口，以便它们可以相互协作。它有两种实现方式：类适配器和对象适配器。

**优点：** 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。

**缺点：** 过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 

**使用场景：**有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。

**示例**：有一个 *MediaPlayer* 接口和一个实现了 *MediaPlayer* 接口的实体类 *AudioPlayer*。默认情况下，*AudioPlayer* 可以播放 mp3 格式的音频文件。我们还有另一个接口 *AdvancedMediaPlayer* 和实现了 *AdvancedMediaPlayer* 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。我们想要让 *AudioPlayer* 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 *MediaPlayer* 接口的适配器类 *MediaAdapter*，并使用 *AdvancedMediaPlayer* 对象来播放所需的格式。*AudioPlayer* 使用适配器类 *MediaAdapter* 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。*AdapterPatternDemo* 类使用 *AudioPlayer* 类来播放各种格式![适配器模式的 UML 图](assets/设计模式/20210223-adapter.png)

#### 装饰器模式(Decorator Pattern)

装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其结构。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。就增加功能来说，装饰器模式相比生成子类更为灵活。

**优点：**装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。

**缺点：**多层装饰比较复杂。

**示例**：创建一个 *Shape* 接口和实现了 *Shape* 接口的实体类。然后我们创建一个实现了 *Shape* 接口的抽象装饰类 *ShapeDecorator*，并把 *Shape* 对象作为它的实例变量。*RedShapeDecorator* 是实现了 *ShapeDecorator* 的实体类。*DecoratorPatternDemo* 类使用 *RedShapeDecorator* 来装饰 *Shape* 对象。

![装饰器模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20210420-decorator-1-decorator-decorator.svg)

#### 代理模式(Proxy Pattern)

代理模式为另一个对象提供代理，以便控制对原始对象的访问。

**优点：** 1、职责清晰。 2、高扩展性。 3、智能化。

**缺点：** 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。

**使用场景：**按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。

**和适配器模式的区别**：适配器模式主要 改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 

**和装饰器模式的区别**：装饰器模式为了增强功能，而代理模式是为了加以控制。

**示例：**创建一个 *Image* 接口和实现了 *Image* 接口的实体类。*ProxyImage* 是一个代理类，减少 *RealImage* 对象加载的内存占用。*ProxyPatternDemo* 类使用 *ProxyImage* 来获取要加载的 *Image* 对象，并按照需求进行显示。

![代理模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20211025-proxy.svg)

### 行为模式

#### 观察者模式

观察者模式是一种行为型设计模式，它定义了对象之间的一种一对多的依赖关系，使得每当一个对象发生改变时，它的所有依赖对象都得到通知并被自动更新。

**优点：** 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。

**缺点：** 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

**使用场景：**

- 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
- 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
- 一个对象必须通知其他对象，而并不知道这些对象是谁。
- 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象···，可以使用观察者模式创建一种链式触发机制。

**示例**：Subject为被观察对象，Observer为观察者对象，观察者对象中有一个成员变量是被观察者，创建观察者对象时将其加入被观察者对象的观察者数组中。被观察者状态发生改变时，自动通知所有观察者，调用观察者的update函数。

![观察者模式的 UML 图](assets/设计模式/observer_pattern_uml_diagram.jpg)

#### 模板模式

模板模式中，抽象类定义了一个算法的步骤(模板方法)，并允许子类为一个或多个步骤提供实现。模板方法模式将算法的骨架和具体实现分离，使得子类可以改变算法的具体实现，同时保持算法的整体结构不变。

**优点：** 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。

**缺点：**每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。

**使用场景：** 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。

**注意事项：**为防止恶意操作，一般模板方法都加上 final 关键词。

**示例：**创建一个定义操作的 *Game* 抽象类，其中，模板方法设置为 final，这样它就不会被重写*Cricket* 和 *Football* 是扩展了 *Game* 的实体类，它们重写了抽象类的方法。

![模板模式的 UML 图](assets/设计模式/template_pattern_uml_diagram.jpg)

#### 策略模式

策略模式中，定义了一系列算法，并将每个算法封装起来，使它们可以相互替换。策略模式使得算法的变化独立于使用算法的对象，从而使得对象可以在运行时动态地选择算法，而无需修改代码。

**优点：** 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。

**缺点：** 1、策略类会增多。 2、所有策略类都需要对外暴露。

**使用场景：** 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。

**示例**：创建一个定义活动的 *Strategy* 接口和实现了 *Strategy* 接口的实体策略类。*Context* 是一个使用了某种策略的类。

![策略模式的 UML 图](assets/设计模式/strategy_pattern_uml_diagram.jpg)

#### 工厂模式和策略模式得区别

1. 关注点不同：工厂模式关注对象的创建，策略模式关注对象的行为。
2. 用途不一样：工厂是创建型模式,它的作用就是创建对象；策略是行为型模式,它的作用是让一个对象在许多行为中选择一种行为。
3. 在工厂模式中，具体对象的创建对客户端是隐藏的，创建过程由工厂完成；在策略模式中，对象的创建是由客户端自己完成的。





